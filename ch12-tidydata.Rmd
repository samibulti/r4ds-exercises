---
title: "Chapter 12: Tidy data"
output: html_notebook
---

```{r}
library(tidyverse)
```

# 12.2 Tidy data

## 12.2.1 Exercises

1. Using prose, describe how the variables and observations are organised in each of the sample tables.

**`table2`: The `type` column indicates whether each row of data contains an observation of the number of cases or the population. This then means that the values for `country` and `year` are duplicated across two rows - each observation is split across those two rows.**

**`table3`: The `rate` column in this case is a string that contains two separate values - `cases` and `population`. Attempting to perform any computation or aggregation with the data in this format would need this string to be broken into separate numeric variables first.**

**`table4`: There are two separate tables, one for the `cases` variable and the other for `population`. Within each table the rows correspond to a country and the columns then contain separate observations on the target variable for each given year. This means that there are multiple observations within each row, yet the observations within each table are incomplete.**

2. Compute the rate for `table2`, and `table4a` + `table4b`. You will need to perform four operations:

  1. Extract the number of TB cases per country per year.
  2. Extract the matching population per country per year.
  3. Divide cases by population, and multiply by 10000.
  4. Store back in the appropriate place.

```{r}
t2cases <- table2 %>%
  filter(type == "cases") %>%
  select(country, year, cases = count)
t2pop <- table2 %>%
  filter(type == "population") %>%
  select(country, year, pop = count)
t2rate <- t2cases %>%
  left_join(t2pop, by = c("country", "year")) %>%
  mutate(rate = (cases / pop) * 10000)
t2rate
```

```{r}
t4rate <- table4a %>%
  left_join(table4b, by = c("country"), suffix = c("cases", "pop")) %>%
  mutate(
    `1999rate` = (`1999cases` / `1999pop`) * 10000,
    `2000rate` = (`2000cases` / `2000pop`) * 10000
  )
t4rate
```

Which representation is easiest to work with? Which is hardest? Why?

**`table3` would be worst of all because it requires text processing. `table2` required some intermediate steps before putting things back together but results in a generally tidy format. `table4a` and `table4b` required some extra arguments to the join function for clarity and ends up putting the calculated rates into two separate columns so it remains untidy.**

3. Recreate the plot showing change in cases over time using `table2` instead of `table1`. What do you need to do first?

```{r}
library(ggplot2)
table2 %>%
  filter(type == "cases") %>%
  ggplot(aes(year, count)) +
    geom_line(aes(group = country), colour = "grey50") +
    geom_point(aes(colour = country)) +
    ylab("cases")
```

**I needed to filter the data to select only the rows that had numbers of cases, and then I also changed the label on the y-axis to correctly describe the variable.**

# 12.3 Spreading and gathering

## 12.3.3 Exercises

1. Why are `gather()` and `spread()` not perfectly symmetrical?

Carefully consider the following example:

```{r}
stocks <- tibble(
  year   = c(2015, 2015, 2016, 2016),
  half  = c(   1,    2,     1,    2),
  return = c(1.88, 0.59, 0.92, 0.17)
)
stocks %>% 
  spread(year, return)  %>% 
  gather("year", "return", `2015`:`2016`)
```

(Hint: look at the variable types and think about column names.)

**`spread()` only needs two arguments because it determines the new column names from the values in the `key` column. All it needs to do is coerce those values to be strings so they can function as variable names. `gather()` needs to be told the new column names and then which existing variables are to be converted into those key-value columns.**

Both `spread()` and `gather()` have a convert argument. What does it do?

**If `convert = TRUE` is passed to either function then it will attempt to convert the new variables to an appropriate type. Note that `year` in the example code above has ended up as a string, because the `gather()` function had used the `2015` and `2016` variable names as strings. Running the same code with conversion will see it return to being a numeric variable, as  shown below.**

```{r}
stocks <- tibble(
  year   = c(2015, 2015, 2016, 2016),
  half  = c(   1,    2,     1,    2),
  return = c(1.88, 0.59, 0.92, 0.17)
)
stocks %>% 
  spread(year, return)  %>% 
  gather("year", "return", `2015`:`2016`, convert = TRUE)
```

2. Why does this code fail?

```{r}
table4a %>% 
  gather(1999, 2000, key = "year", value = "cases")
```

**The existing variable names are non-syntactic so the arguments need to be surrounded by backticks - see below.**

```{r}
table4a %>% 
  gather(`1999`, `2000`, key = "year", value = "cases")
```

3. Why does spreading this tibble fail? How could you add a new column to fix the problem?

```{r}
people <- tribble(
  ~name,             ~key,    ~value,
  #-----------------|--------|------
  "Phillip Woods",   "age",       45,
  "Phillip Woods",   "height",   186,
  "Phillip Woods",   "age",       50,
  "Jessica Cordero", "age",       37,
  "Jessica Cordero", "height",   156
)
people %>%
  spread(key, value)
```

**The third row in the original dataset has the same name and key as the first row, i.e., the function runs into a situation where there are two possible values to go into the one cell for Phillip Woods's age column. You could add a column that allows the tidying function to uniquely identify people who might have the same name, e.g., add an address or a unique ID number.**

4. Tidy the simple tibble below. Do you need to spread or gather it? What are the variables?

```{r}
preg <- tribble(
  ~pregnant, ~male, ~female,
  "yes",     NA,    10,
  "no",      20,    12
)
preg %>%
  gather("sex", "n", `male`:`female`)
```
